RMQAnalysis1 class: SUBQUERY SİZE SABİT TUTULDU. UNSORTED ARRAYDE SİZE'LARI SIRAYLA 500, 5000, 10000 YAPARAK Naive, Precompute All, Sparse Table, Blocking RMQ ALGORİTMALARININ QUERY VE BUILD SÜRESİ KARŞILAŞTIRMASI YAPILDI.

RMQAnalysis : SİZE, SUBQUERY SİZE SABİT TUTULDU. SORTED, UNSORTED, REVERSE SORTED ARRAY'LERİNDE Naive, Precompute All, Sparse Table, Blocking RMQ ALGORİTMALARININ QUERY VE BUILD SÜRESİ KARŞILAŞTIRMASI YAPILDI.

RMQAnalysis2 : SİZE, SUBQUERY SİZE SABİT TUTULDU. SORTED, UNSORTED, REVERSE SORTED ARRAY'LERİNDE Naive, Precompute All, Sparse Table, Blocking RMQ ALGORİTMALARININ SPACE COMLEXİTY KARŞILAŞTIRILMASI YAPILDI.

RMQQueryTest : SİZE SBAİT TUTULDU. SORTED, UNSORTED, REVERSE SORTED ARRAY'LERİNDE Naive, Precompute All, Sparse Table, Blocking RMQ ALGORİTMALARI İÇİN SUBQUERY SİZE'LARI DEĞİŞTİRİLEREK KARŞILAŞTIRMA YAPILDI.


Project Tasks: 

1. Problem Description : Provide the formal definition of RMQ.
  
2. Algorithms*  : Provide a detailed description of each approach and analyze the theoretical 
performance. Algorithms are as follows: (1) Precompute all, (2) Sparse table, (3) Blocking, (4) 
Precompute none.
 
3. Implementation  : Implement the algorithms in Java or C.  
4. Experimental Design  : Design and conduct experiments to analyze time complexities of each 
algorithm empirically.

5. Results   : Provide experimental results. Your report can include graphs, tables, and 
charts to visualize the performance comparisons.

6. Conclusion  : Summarize key insights gained from the comparative analysis.
